package settings

import (
	"net/url"
	"path"
	"path/filepath"
	"strings"
	"unicode"
)

type Output struct {
	// Root is the directory to which generated files will be written.
	Root string
	// Sub is a path that follows the output directory and precedes a
	// generated file path.
	Sub string
	// Resources is the path relative to Sub where generated resource files
	// will be written.
	Resources string
	// DocResources is the path relative to Sub where document resource files
	// will be written.
	DocResources string
	// Manifest is the path relative to Sub that points to the manifest file.
	Manifest string
	// Host is the host part of the absolute URL of the site.
	Host string
}

// Escape once to escape the file name, then again to escape the URL.
func doubleEscape(s string) string {
	return url.PathEscape(url.PathEscape(s))
}

func pathText(text string) string {
	var s []rune
	var dash bool
	for _, r := range text {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			s = append(s, r)
			dash = false
		} else if !dash && unicode.IsSpace(r) {
			s = append(s, '-')
			dash = true
		}
	}
	return string(s)
}

func anchorText(text string) string {
	var s []rune
	var dash bool
	for _, r := range text {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			s = append(s, unicode.ToLower(r))
			dash = false
		} else if !dash {
			s = append(s, '-')
			dash = true
		}
	}
	return string(s)
}

// FileLink generates a URL, relative to an arbitrary host.
func (o *Output) FileLink(linkType string, args ...string) (s string) {
retry:
	switch strings.ToLower(linkType) {
	case "index":
		s = "index" + FileExt
	case "resource":
		s = path.Join(o.Resources, path.Join(args...))
	case "docres":
		s = path.Join(o.DocResources, path.Join(args...))
	case "updates":
		if len(args) > 0 {
			s = path.Join("updates", doubleEscape(args[0])+FileExt)
		} else {
			s = "updates" + FileExt
		}
	case "class":
		s = path.Join(ClassPath, doubleEscape(args[0])+FileExt)
	case "member":
		if len(args) == 1 {
			return (&url.URL{Fragment: MemberAnchorPrefix + args[0]}).String()
		} else if len(args) == 2 {
			s = path.Join(ClassPath, doubleEscape(args[0])+FileExt) +
				(&url.URL{Fragment: MemberAnchorPrefix + args[1]}).String()
		}
	case "enum":
		s = path.Join(EnumPath, doubleEscape(args[0])+FileExt)
	case "enumitem":
		if len(args) == 1 {
			return (&url.URL{Fragment: MemberAnchorPrefix + args[0]}).String()
		} else if len(args) == 2 {
			s = path.Join(EnumPath, doubleEscape(args[0])+FileExt) +
				(&url.URL{Fragment: MemberAnchorPrefix + args[1]}).String()
		}
	case "type":
		if len(args) == 1 {
			s = path.Join(TypePath, doubleEscape(args[0])+FileExt)
		} else if len(args) == 2 {
			switch strings.ToLower(args[0]) {
			case "class", "enum":
				a := make([]string, 2)
				linkType, a[0] = args[0], args[1]
				args = a
				goto retry
			}
			s = path.Join(TypePath, doubleEscape(args[1])+FileExt)
		}
	case "about":
		s = "about" + FileExt
	case "docmon":
		s = "docmon" + FileExt
	case "search":
		s = "search.db"
	case "manifest":
		s = o.Manifest
	case "devhub":
		switch linkType = strings.ToLower(args[0]); linkType {
		case "class", "enum":
			return "https://" + path.Join(DevHubURL, linkType, pathText(args[1]))
		case "property", "function", "event", "callback":
			return "https://" + path.Join(DevHubURL, linkType, pathText(args[1]), pathText(args[2]))
		case "enumitem":
			return "https://" + path.Join(DevHubURL, "enum", pathText(args[1])) + "#" + anchorText(args[2])
		case "type":
			return "https://" + path.Join(DevHubURL, "datatype", pathText(args[1]))
		}
	}
	s = path.Join("/", o.Sub, s)
	return s
}

// FilePath generates a file path relative to the output root directory. On a
// web server serving static files, the returned path is meant to point to the
// same file as the file pointed to by the URL generated by FileLink.
func (o *Output) FilePath(typ string, args ...string) string {
	return o.PathFromLink(o.FileLink(typ, args...))
}

// AbsFilePath generates an absolute path located in the Output. On a web
// server serving static files, the returned path is meant to point to the
// same file as the file pointed to by the URL generated by FileLink.
func (o *Output) AbsFilePath(typ string, args ...string) string {
	return o.AbsPathFromLink(o.FileLink(typ, args...))
}

// LinkFromPath transforms a path into a link, if possible.
func (o *Output) LinkFromPath(p string) string {
	if l, err := filepath.Rel(o.Root, p); err == nil {
		return path.Clean(l)
	}
	return path.Clean(p)
}

// PathFromLink transforms a link into a path, if possible.
func (o *Output) PathFromLink(l string) string {
	l, _ = url.PathUnescape(l)
	l = strings.TrimPrefix(l, "/")
	return filepath.Clean(l)
}

// AbsPathFromLink transforms a link into an absolute path, if possible.
func (o *Output) AbsPathFromLink(l string) string {
	l, _ = url.PathUnescape(l)
	l = strings.TrimPrefix(l, "/")
	return o.AbsPath(l)
}

// AbsPath transforms a relative path into an absolute path.
func (o *Output) AbsPath(p string) string {
	if filepath.IsAbs(p) {
		return p
	}
	return filepath.Join(o.Root, p)
}

func unescapeURLPath(path string) string {
	p, err := url.PathUnescape(path)
	if err != nil {
		return path
	}
	return p
}

func (o *Output) ParseDocReference(ref string) (scheme, path, link string) {
	colon := strings.IndexByte(ref, ':')
	if colon < 0 {
		return "", "", ref
	}
	switch scheme, path = ref[:colon], ref[colon+1:]; scheme {
	case "res":
		link = o.FileLink("docres", path)
		return
	case "class":
		slash := strings.IndexByte(path, '/')
		if slash < 0 {
			link = o.FileLink("class", unescapeURLPath(path))
			return
		}
		link = o.FileLink("member", unescapeURLPath(path[:slash]), unescapeURLPath(path[slash+1:]))
		return
	case "enum":
		slash := strings.IndexByte(path, '/')
		if slash < 0 {
			link = o.FileLink("enum", unescapeURLPath(path))
			return
		}
		link = o.FileLink("enumitem", unescapeURLPath(path[:slash]), unescapeURLPath(path[slash+1:]))
		return
	case "type":
		link = o.FileLink("type", unescapeURLPath(path))
		return
	case "member":
		link = o.FileLink("member", unescapeURLPath(path))
		return
	}
	return "", "", ref
}
